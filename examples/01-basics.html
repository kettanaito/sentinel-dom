<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Basics</title>
  <link rel="stylesheet" href="styles/base.css" />
</head>
<body>
  <script src="../lib/index.js"></script>

  <h1>Basics</h1>
  <section>
    <h2 id="absolute-tracking">Absolute tracking</h2>
    <p>By default, targets are tracked against the window. While this is suitable for most cases, it is highly recommended to provide custom boundaries to increase the tracking performance.</p>
    <center>
      <div id="target-absolute" class="target"></div>
    </center>
    <!-- <pre data-example="example-01"></pre> -->
  </section>

  <section>
    <h2 id="relative-tracking">Relative tracking</h2>
    <p>You can track the target relatively to the custom boundaries (i.e. parent DOMElement). Simply pass the container's DOMElement reference in the <code>bounds</code> option.</p>
    <h3>Behind the scenes</h3>
    <p>The benefit of using custom boundaries is that no tracking is performed if the boundaries lie beyond the current viewport. This can significantly save resources when performing heavy tracking.</p>
    <div class="grid">
      <div>
        <div class="target target-relative" data-label="outside bounds"></div>
      </div>
      <div id="target-relative-bounds" class="bounds">
        <div class="target target-relative" data-label="within bounds"></div>
        <div class="target target-relative" data-label="within bounds"></div>
      </div>
      <div>
        <div class="target target-relative" data-label="outside bounds"></div>
      </div>
    </div>
  </section>

  <section>
    <h2 id="unique-impressions">Manual tracking</h2>
    <p>You can store an initialized instance of a tracker to access its public methods at any time. This is particularly useful when the tracking cannot fully rely on scroll event and should also be performed manually (i.e. on carousel slide change).</p>
    <p><strong>Note:</strong> A <code>manual</code> property is set to "true" only for illustrational purposes (so that scrolling would not trigger visibility check). Provide it <strong>only</strong> when you need to disable tracking on scroll explicitly. It is perfectly fine to have both scroll and manual tracking at the same time.</p>
    <div class="grid">
      <div>
        <div class="target target-manual"></div>
      </div>
      <div>
        <div class="target target-manual"></div>
      </div>
      <div>
        <div class="target target-manual"></div>
      </div>
    </div>
    <button id="manual-trigger">Track</button>
  </section>

  <section>
    <h2 id="unique-impressions">Unique impressions</h2>
    <p>One of the frequent requirements toward any visibility tracking is to be able to handle a view or impression only once. Achieve this delightfully setting <code>once: true</code>.</p>
    <h3>Behind the scenes</h3>
    <p>There is a custom logic dedicated to handling unique impressions. In simple words, once the target it tracked the first time, it sets a certain internal flag, which prevents further tracking related to the target to be performed. So once the traget is tracked, it gets omitted from the further tracking operations completely, saving up the resources.</p>
    <div class="bounds">
      <div class="target"></div>
    </div>
  </section>

  <script id="example-01">
    new Sentinel.Tracker({
      targets: document.getElementById('target-absolute'),
      snapshots: [
        {
          name: 'Box becomes visible',
          once: true,
          callback({ DOMElement }) {
            DOMElement.classList.add('tracked');
          }
        }
      ]
    });
  </script>

  <script id="example-02">
    new Sentinel.Tracker({
      targets: document.getElementsByClassName('target-relative'),
      bounds: document.getElementById('target-relative-bounds'),
      snapshots: [
        {
          name: 'Becomes visible',
          thresholdX: 20,
          callback({ DOMElement }) {
            DOMElement.classList.add('tracked');
          }
        }
      ]
    });
  </script>

  <script id="example-03">
    var manualTracker = new Sentinel.Tracker({
      targets: document.getElementsByClassName('target-manual'),
      manual: true,
      snapshots: [
        {
          callback({ DOMElement}) {
            DOMElement.classList.add('tracked');
          }
        }
      ]
    });

    document.getElementById('manual-trigger').addEventListener('click', manualTracker.track);
  </script>

  <script>
    const examplePlaceholders = Array.from(document.querySelectorAll('[data-example]'));
    examplePlaceholders.forEach((DOMElement) => {
      const scriptContent = document.getElementById(DOMElement.dataset.example);
      DOMElement.innerHTML = scriptContent.innerHTML;
    });
  </script>
</body>
</html>